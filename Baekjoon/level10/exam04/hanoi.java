package level10.exam04;

import java.util.Scanner;

public class hanoi {
	
	// 출저 : https://www.acmicpc.net/problem/11729

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt(); // 원판의 개수
		sc.close();
		
		/* 하노이탑 규칙 : 작은 원판 위에 큰 원판은 올 수 없다.
		 * 1 2 3 4 5 : - - - - - : - - - - - 
		 * - 2 3 4 5 : - - - - - : - - - - 1
		 * - - 3 4 5 : - - - - 2 : - - - - 1
		 * - - 3 4 5 : - - - 1 2 : - - - - -
		 * - - - 4 5 : - - - 1 2 : - - - - 3 
		 * - - 1 4 5 : - - - - 2 : - - - - 3
		 * - - 1 4 5 : - - - - - : - - - 2 3
		 * - - - 4 5 : - - - - - : - - 1 2 3
		 * - - - - 5 : - - - - 4 : - - 1 2 3
		 * - - - 1 5 : - - - - 4 : - - - 2 3
		 * - - - 1 5 : - - - 2 4 : - - - - 3 
		 * - - - - 5 : - - 1 2 4 : - - - - 3 
		 * - - - 3 5 : - - 1 2 4 : - - - - -
		 * - - - 3 5 : - - - 2 4 : - - - - 1 
		 * - - 2 3 5 : - - - - 4 : - - - - 1
		 * - - 2 3 5 : - - - 1 4 : - - - - -
		 * - - - 3 5 : - - - 1 4 : - - - - 2
		 * - - - 3 5 : - - - - 4 : - - - 1 2
		 * - - - - 5 : - - - 3 4 : - - - 1 2
		 * - - - 1 5 : - - - 3 4 : - - - - 2
		 * - - - 1 5 : - - 2 3 4 : - - - - -
		 * - - - - 5 : - 1 2 3 4 : - - - - - [원판 1~4를 B로 이동]
		 * - - - - - : - 1 2 3 4 : - - - - 5 [가장 큰 원판 5를 C로 이동]
		 * - - - - 1 : - - 2 3 4 : - - - - 5 [B에 있는 원판 1~4를 C로 이동]
		 * - - - - 1 : - - - 3 4 : - - - 2 5
		 * - - - - - : - - - 3 4 : - - 1 2 5
		 * - - - - - : - - - - 4 : - - 1 2 5
		 * - - - - 3 : - - - - 4 : - - 1 2 5
		 * - - - - 3 : - - - 1 4 : - - - 2 5
		 * - - - 2 3 : - - - 1 4 : - - - - 5
		 * - - 1 2 3 : - - - - 4 : - - - - 5
		 * - - 1 2 3 : - - - - - : - - - 4 5
		 * - - - 2 3 : - - - - - : - - 1 4 5
		 * - - - - 3 : - - - - 2 : - - 1 4 5
		 * - - - - 3 : - - - 1 2 : - - - 4 5
		 * - - - - - : - - - 1 2 : - - 3 4 5
		 * - - - - 1 : - - - - 2 : - - 3 4 5
		 * - - - - 1 : - - - - - : - 2 3 4 5
		 * - - - - - : - - - - - : 1 2 3 4 5 
		 * 
		 * 1. 가장 큰 원판(5)을 C로 옮기기 위해서는 n-1개의 원판(1~4)이 A에서 B로 가야한다 : Hanoi(n-1)
		 * 2. A에 있는 가장 큰 원판(5)이 C로 이동 : 1
		 * 3. B에 있는 n-1개의 원판(1~4)을 C로 이동 : Hanoi(n-1)
		 * 
		 * 공식화
		 * Hanoi(n) = 2 * Hanoi(n-1) + 1 
		 * a(n) = a(n-1) + 1 + a(n-1)
		 * a(n) = 2*a(n-1)+1 
		 * a(1) = 1, a(n+1) = 2a(n)+1
		 * a(n+1) + 1 = 2(a(n) + 1)
		 * b(n) = a(n) + 1 이라 정의할 때
		 * b(n+1) = 2b(n)
		 * b(1) = a(1) + 1 = 2 
		 * 즉 첫째항은 2이고, 공비는 2인 공비수열 
		 * b(n) = a(n) + 1 = 2ⁿ
		 * 즉 a(n) = 2ⁿ-1
		 */
		
		System.out.println((int)Math.pow(2, N) - 1); // Math.pow () : 거듭제곱을 구하는 함수
		Hanoi(N, 1, 2, 3); // 원판의 개수, 출발지, 중간지점, 목적지

	}

	private static void Hanoi(int N, int start, int mid, int to) {
		/*
		N : 원판의 개수
		start : 출발지
		mid : 옮기기 위해 이동할 장소
		to : 목적지
		*/
		
		// 이동할 원반의 수가 1개
		if(N == 1) {
			System.out.println(start + " " + to);
			return;
		}
		// 1단계 : N-1개를 A에서 B로 이동
		Hanoi(N-1, start, to, mid);
		
		// 2단계 : 1개를 A에서 C로 이동
		System.out.println(start + " " + to);
		
		// 3단계 : N-1개를 B에서 C로 이동
		Hanoi(N-1, mid, start, to);
	}

}
